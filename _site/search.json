[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This blog encompasses a variety of Data Science projects."
  },
  {
    "objectID": "Analyse.html",
    "href": "Analyse.html",
    "title": "Analyse",
    "section": "",
    "text": "library(tidyverse)\n\n-- Attaching packages --------------------------------------- tidyverse 1.3.1 --\n\n\nv ggplot2 3.4.4     v purrr   1.0.1\nv tibble  3.2.1     v dplyr   1.1.2\nv tidyr   1.2.0     v stringr 1.5.0\nv readr   2.1.2     v forcats 0.5.1\n\n\n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\nlibrary(tokenizers)\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(hcandersenr)\nlibrary(SnowballC)  # Stemming\nlibrary(lsa)  # Stopwörter\nlibrary(easystats)  # Komfort für deskriptive Statistiken, wie `describe_distribution`\n\n# Attaching packages: easystats 0.6.0 (red = needs update)\nv bayestestR  0.13.1   v correlation 0.8.4 \nx datawizard  0.7.1    x effectsize  0.8.3 \nx insight     0.19.2   v modelbased  0.8.6 \nx performance 0.10.3   x parameters  0.21.0\nx report      0.5.7    v see         0.8.1 \n\nRestart the R-Session and update packages in red with `easystats::easystats_update()`.\n\nlibrary(textclean)  # Emojis ersetzen\nlibrary(wordcloud)\n\nLade nötiges Paket: RColorBrewer"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Raucherstatus Klassifikation\n\n\n\n\n\n\n\n\n\n\n\n\nJan 12, 2024\n\n\nEmilia Braun\n\n\n\n\n\n\n  \n\n\n\n\nKlassifikation von Hate Speech\n\n\n\n\n\n\n\nTextanalyse\n\n\nTidymodels\n\n\nKlassifikation\n\n\n\n\n\n\n\n\n\n\n\nNov 28, 2023\n\n\nEmilia Braun\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Angewandtes Projekt/Projekt.html",
    "href": "posts/Angewandtes Projekt/Projekt.html",
    "title": "Raucherstatus Klassifikation",
    "section": "",
    "text": "Anhand von verschiedenen biologischen Daten und Signalen soll in einer Soft Classification bestimmt werden, mit welcher Wahrscheinlichkeit eine Person Raucher ist.\n\n\nIm Folgenden sollen sowohl neue Beobachtungsfälle auf ihre Wahrscheinlichkeit hin, Raucher zu sein, klassifiziert werden, als auch mögliche Effekte von biologischen Signalen auf den Raucherstatus identifiziert werden.\nWarum könnte eine Klassifikation des Raucherstatus interessieren?\n\n\nGesundheitswesen: Eine Klassifikation des Raucherstatus auf Basis von biologischen Signalen kann verwendet werden, um Menschen mit einem erhöhten Risiko für Raucherkrankheiten zu identifizieren. Dies kann dazu beitragen, diese Krankheiten zu verhindern oder zu behandeln.\nRaucherentwöhnung: Eine Klassifikation des Raucherstatus auf Basis von biologischen Signalen kann verwendet werden, um die Wirksamkeit von Raucherentwöhnungsmaßnahmen zu bewerten. Dies kann dazu beitragen, die Entwicklung neuer und effektiverer Raucherentwöhnungsmaßnahmen zu unterstützen.\nMarktforschung: Eine Klassifikation des Raucherstatus auf Basis von biologischen Signalen kann verwendet werden, um neue Produkte und Dienstleistungen für Raucher zu entwickeln. Dies kann dazu beitragen, die Raucherprävention und -entwöhnung zu unterstützen.\n\n\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(easystats)\nlibrary(glmnet)\nlibrary(corrr)\nlibrary(fastDummies)\nlibrary(reshape2)\nlibrary(lubridate)\nlibrary(tictoc)\nlibrary(xgboost)\nlibrary(doParallel)\nlibrary(cowplot)\nlibrary(rlang)\nlibrary(purrr)\nlibrary(timetk)\nlibrary(discrim)\nlibrary(ggthemes)\nlibrary(klaR)\nlibrary(rstanarm)\nlibrary(car)\nlibrary(caret)\nlibrary(pROC)\n\n\n\n\nDie Daten stammen von einer kaggle Competition. Es gibt einen train und einen test Datensatz.\nEs geht darum, Menschen als Raucher oder Nicht-Raucher anhand von verschiedenen biologischen Signalen und Eigenschaften zu klassifizieren. Dabei soll die Klassifikation aber nicht hart sein, also nur aussagen ob man Raucher ist oder nicht, sondern es soll eine weiche Klassifikation sein, die angibt, mit welcher Wahrscheinlichkeit jemand aufgrund der vorliegenden Daten Raucher ist.\n\nd_train &lt;- read_csv(path_train)\nd_test &lt;- read_csv(path_test)\n\nSchauen wir uns die Daten einmal an. Der Datensatz besteht aus 24 Variablen, wovon eine die ID-Spalte ist und eine die vorzusagende Variable smoking.\n\nd_train\n\n\n\n  \n\n\n\nDer Train Datensatz wird nochmal in train und test Daten gesplittet. Davor werden einige Variablen für einfacheres Handling noch umbenannt und die AV wird als Faktorvariable angelegt.\n\nd_train &lt;-\n  d_train |&gt; \n  mutate(weight = `weight(kg)`,\n         waist = `waist(cm)`,\n         height = `height(cm)`,\n         eyesight_left = `eyesight(left)`,\n         eyesight_right = `eyesight(right)`,\n         hearing_left = `hearing(left)`,\n         hearing_right = `hearing(right)`,\n         dental_caries = `dental caries`) |&gt; \n  dplyr::select(-`weight(kg)`, -`height(cm)`, -`eyesight(left)`, -`eyesight(right)`, -`hearing(left)`, -`hearing(right)`, - `dental caries`, -`waist(cm)`)\n\nd_test &lt;-\n  d_test |&gt; \n  mutate(weight = `weight(kg)`,\n         waist = `waist(cm)`,\n         height = `height(cm)`,\n         eyesight_left = `eyesight(left)`,\n         eyesight_right = `eyesight(right)`,\n         hearing_left = `hearing(left)`,\n         hearing_right = `hearing(right)`,\n         dental_caries = `dental caries`) |&gt; \n  dplyr::select(-`weight(kg)`, - `height(cm)`, -`eyesight(left)`, -`eyesight(right)`, -`hearing(left)`, -`hearing(right)`, - `dental caries`, -`waist(cm)`)\n\ncolnames(d_test) &lt;- gsub(\" \", \"_\", colnames(d_test))\n\nd_trainf &lt;-\n  d_train |&gt; \n  mutate(smokingf = factor(smoking)) |&gt; \n  dplyr::select(-smoking)\n\ncolnames(d_trainf) &lt;- gsub(\" \", \"_\", colnames(d_trainf))\n\nd_split &lt;- initial_split(d_trainf, prop = .8, strata = smokingf)\ntrain &lt;- training(d_split)\ntest &lt;- testing(d_split)\n\n\n\n\n\n\n\n\nsum(is.na(d_trainf))\n\n[1] 0\n\nvisdat::vis_dat(d_trainf, warn_large_data = FALSE)\n\n\n\n\nIm Datensatz gibt es keine fehlenden Werte. Bis auf die AV liegen nur nummerische Variablen vor.\n\n\n\n\n\nShow the code\ns_cor &lt;-\n  d_train |&gt;\n  dplyr::select(-id) |&gt; \n  correlate() |&gt; \n  shave()\n\ns_cor\n\n\n\n\n  \n\n\n\nShow the code\ns_cor2 &lt;-\n  d_train |&gt; \n  dplyr::select(-id)\n\ncorr_matrix &lt;- cor(s_cor2)\ncorr_melted &lt;- melt(corr_matrix)\n\nggplot(corr_melted, aes(x=Var1, y=Var2, fill=value)) + \n  geom_tile() +\n  scale_fill_gradient2(low=\"blue\", mid=\"white\", high=\"red\", midpoint=0) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +\n  labs(title=\"Korrelations-Heatmap für accidents\")\n\n\n\n\n\n\n\n\n\nd_train |&gt; \n  count(smoking == 1) |&gt; \n  mutate(Anteil = n/sum(n))\n\n\n\n  \n\n\n\n–&gt; Die AV scheint einigermaßen gleichverteilt zu sein.\n\n\n\n\n\nShow the code\n# Funktion zur Erstellung eines Histogramms mit Facettierung\ncreate_histogram_plot &lt;- function(data, variable) {\n  ggplot(data, aes(x = !!sym(variable))) +\n    geom_histogram() +\n    labs(x = variable, y = \"Häufigkeit\") +\n    theme(\n    text = element_text(color = \"darkblue\"),  # Ändere die Farbe des Texts\n    panel.background = element_rect(fill = \"lightgray\"),  # Hintergrundfarbe des Plots\n    panel.grid.major = element_line(color = \"white\"),  # Farbe der Hauptgitterlinien\n    panel.grid.minor = element_line(color = \"lightblue\"),  # Farbe der Nebengitterlinien\n    strip.background = element_rect(fill = \"cyan\"),  # Hintergrundfarbe der Facettenüberschriften\n    strip.text = element_text(color = \"black\"),  # Farbe des Texts in den Facettenüberschriften\n    axis.title = element_text(color = \"purple\"),  # Farbe der Achsentitel\n    axis.text = element_text(color = \"black\"),  # Farbe des Achsentexts\n    axis.line = element_line(color = \"blue\"),  # Farbe der Achsenlinien\n    panel.border = element_rect(color = \"darkgray\", fill = NA),  # Farbe der Panelgrenzen\n    plot.background = element_rect(fill = \"lightyellow\")  # Hintergrundfarbe des gesamten Plots\n  ) +\n    facet_wrap(~ ., scales = \"free\")\n}\n\n# Liste der Variablen, für die Plots erstellt werden sollen\nvariables_to_plot &lt;- c(\"smoking\", \"age\", \"height\", \"weight\", \"triglyceride\", \"hemoglobin\")\n\n# Erstelle die Plots für jede Variable\nplots_list &lt;- map(variables_to_plot, ~ create_histogram_plot(data = d_train, variable = .x))\n\n# Kombiniere die Plots in einem Raster\nplot_grid(plotlist = plots_list, ncol = 3)\n\n\n\n\n\nDie Variable smoking ist einigermaßen gleichverteilt, was für die Klassifikation natürlich sinnvoll ist, jedoch vielleicht kein gutes Bild der gesamten Population. In Deutschland liegt der Anteil an regelmäßig Rauchenden bei ca. 25 % (WHO, 2025).\nDie Variable age ist einigermaßen erwartungsmäßig verteilt, wobei es einen erstaunlich hohen Anteil an 40 Jährigen gibt.\nDie Variablen heigth und weight sind beide wie zu erwarten normalverteilt.\ntriglyceride, welche im medizinischen Bereich auch im Rahmen der Blutanalyse gemessen werden und zusammen mit Cholosterol zur Bestimmung von Fettwechselstörung notwendig sind, liegen bei einem Erwachsenen zwischen 40 - 240 mg/dl (natürlich auch abhängig von Alter und Geschlecht) (Rassow & Netzker, 2016). Deshalb macht die Verteilung der Werte auch Sinn so wie dargestellt.\nhemoglobin ist Teil der roten Blutkörperchen und ein Protein, in dessen Mitte ein Eisenatom liegt, welches Sauerstoff anlagern kann. Typische Werte liegen zwischen 12 und 19 g/dl (natürlich auch wieder abhängig von Alter und Geschlecht) (DRK, 2021), weshalb auch hier die Verteilung wieder sinnvoll erscheint.\n\n\n\n\n\nShow the code\n# Plot für Alter erstellen\n\nggplot(d_trainf, aes(x = age, fill = smokingf)) +\n  geom_bar(position = \"dodge\", width = 4)  +\n  labs(title = \"Häufigkeit von Alter nach Raucherstatus\",\n       x = \"Alter\",\n       y = \"Häufigkeit\",\n       fill = \"Raucher\")  +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\nWarning: `position_dodge()` requires non-overlapping x intervals\n\n\n\n\n\nDer größte Anteil in beiden Gruppen scheint bei 40 Jahren zu sein. Bei den Rauchern scheint es aber nochmal einen beachtlichen Anteil an 60 Jährigen zu geben im Vergleich zu den Nicht-Rauchern.\n\n\nShow the code\n# Plot für Gewicht erstellen\n\nggplot(d_trainf, aes(x = weight, fill = smokingf)) +\n  geom_bar(position = \"dodge\", width = 4)  +\n  labs(title = \"Häufigkeit von Gewicht nach Raucherstatus\",\n       x = \"Gewicht\",\n       y = \"Häufigkeit\",\n       fill = \"Raucher\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\nWarning: `position_dodge()` requires non-overlapping x intervals\n\n\n\n\n\nDie Nicht-Raucher haben bis 65 kg den höheren Anteil an der Verteilung, darüber gibt es mehr Raucher als Nicht-Raucher.\n\n\nShow the code\n# Plot für Größe erstellen\n\nggplot(d_trainf, aes(x = height, fill = smokingf)) +\n  geom_bar(position = \"dodge\", width = 4)  +\n  labs(title = \"Häufigkeit von Größe nach Raucherstatus\",\n       x = \"Größe\",\n       y = \"Häufigkeit\",\n       fill = \"Raucher\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\nWarning: `position_dodge()` requires non-overlapping x intervals\n\n\n\n\n\nEs gibt sehr viel mehr kleinere Nicht-Raucher als kleine Raucher (klein: &lt; 160 cm). Andersherum gibt es viel mehr große Raucher (groß: &gt; 170 cm) als große Nicht-Raucher. Interessant wäre hierbei noch zu wissen, wie die Geschlechterverteilung aussieht, denn falls es mehr männliche als weibliche Raucher geben würde, dann macht es auch Sinn, dass es mehr große Raucher gibt. Leider gibt es dazu keine Daten in dem Datensatz.\n\n\nShow the code\n# Plot für Karies erstellen\n\nggplot(d_trainf, aes(x = dental_caries, fill = smokingf)) +\n  geom_bar(position = \"dodge\") +\n  labs(title = \"Häufigkeit von Karies nach Raucherstatus\",\n       x = \"Karies\",\n       y = \"Häufigkeit\",\n       fill = \"Raucher\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nInsgesamt gibt es viel weniger Menschen mit Karies, wobei es etwas mehr Raucher als Nicht-Raucher sind.\n\n\n\nHier waren einmal typische Merkmalen der Beobachtungsfälle interessant als auch vereinzelte Daten zu biochemischen Signalen.\n\n\nShow the code\nggplot(d_trainf, aes(x = smokingf, y = height, fill = smokingf)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot der Größe nach Raucherstatus\", x = \"Raucherstatus\", y = \"Größe\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  summarise(mean(height))\n\n\n\n\n  \n\n\n\nAnscheinend sind Raucher (mean = 169.74 cm) im Durchschnitt etwas größer als Nicht-Raucher (mean = 161.79 cm). Zudem scheinen Nicht-Raucher breiter gestreut zu sein als Raucher. Die Verteilung zur Größer der Nicht-Raucher könnte möglicherweise auch nicht ganz normalverteilt sein. Die\n\n\nShow the code\nggplot(d_trainf, aes(x = smokingf, y = weight, fill = smokingf)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot des Gewichts nach Raucherstatus\", x = \"Raucherstatus\", y = \"Gewicht\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  summarise(mean(weight))\n\n\n\n\n  \n\n\n\nNicht-Raucher scheinen im Durchschnitt mit 63.24 kg etwas leichter zu sein als die Raucher mit 72.16 kg. Die Nicht-Raucher haben mehr Ausreißer nach oben hin, während es bei den Rauchern sowohl Ausreißer nach unten als nach oben gibt. Beide Gruppen scheinen nicht ganz normalverteilt zu sein.\n\n\nShow the code\nggplot(d_trainf, aes(x = smokingf, y = age, fill = smokingf)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot des Alters nach Raucherstatus\", x = \"Raucherstatus\", y = \"Alter\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  summarise(mean(age))\n\n\n\n\n  \n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  count(age &lt; 20)\n\n\n\n\n  \n\n\n\nRaucher liegen mit 41.5 Jahren durschnittlich unter den Nicht-Rauchern mit 46.5 Jahren. Es gibt in beiden Gruppen keine Personen, die unter 20 Jahren sind, also wurden wohl nur Daten zu Personen &gt;= 20 gesammelt. Beide Gruppen scheinen nicht ganz normalverteilt zu sein.\n\n\nShow the code\nggplot(d_trainf, aes(x = smokingf, y = Cholesterol, fill = smokingf)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot Cholersterol nach Raucherstatus\", x = \"Raucherstatus\", y = \"Cholesterol\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  summarise(mean(Cholesterol))\n\n\n\n\n  \n\n\n\nDie Cholosterol-Spiegel sind für beide Gruppen ähnlich. Auch sonst gibt es wenig Auffäligkeiten.\n\n\nShow the code\nggplot(d_trainf, aes(x = smokingf, y = hemoglobin, fill = smokingf)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot des Hemoglobins nach Raucherstatus\", x = \"Raucherstatus\", y = \"Hemoglobin\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  summarise(mean(hemoglobin))\n\n\n\n\n  \n\n\n\nDer Hämoglobin Wert für die Raucher liegt knapp über 15, während er bei den Nicht-Rauchern knapp unter 15 liegt. Bei den Nicht-Raucher gehen die Ausreißer jedoch auch unter den Wert 7.5, während es bei den Rauchern etwas mehr Ausreißer nach oben hin gibt bzw diese haben höhere Werte als die Ausreißer der Nicht-Raucher.\n\n\n\n\nUm zu überprüfen, welche Variablen einen Einfluss auf die AV haben, wurde im Folgenden ein stan_glm aufgestellt und anschließend das rope berechnet.\n\nm1 &lt;- stan_glm(smoking ~ ., data = d_train, seed = 42, refresh = 0)\n\nparameters(m1)\n\n\n\n  \n\n\nrope(m1)\n\nPossible multicollinearity between relaxation and systolic (r = 0.72), HDL and Cholesterol (r = 0.72), HDL and triglyceride (r = 0.7), waist and weight (r = 0.79). This might lead to inappropriate results. See 'Details' in '?rope'.\n\n\n\n\n  \n\n\nplot(rope(m1))\n\nPossible multicollinearity between relaxation and systolic (r = 0.72), HDL and Cholesterol (r = 0.72), HDL and triglyceride (r = 0.7), waist and weight (r = 0.79). This might lead to inappropriate results. See 'Details' in '?rope'.\n\n\n\n\nvif(m1)\n\n                   id                   age              systolic \n             1.018681              1.887934              2.587834 \n           relaxation `fasting blood sugar`           Cholesterol \n             2.505630              1.142631              7.455405 \n         triglyceride                   HDL                   LDL \n             3.078763              3.389189              6.134903 \n           hemoglobin       `Urine protein`    `serum creatinine` \n             1.905295              1.017452              1.445274 \n                  AST                   ALT                   Gtp \n             1.741287              1.959108              1.339327 \n               weight                 waist                height \n             6.919126              4.749702              2.929081 \n        eyesight_left        eyesight_right          hearing_left \n             1.319455              1.342833              1.487325 \n        hearing_right         dental_caries \n             1.460736              1.026594 \n\n\nAnscheinend haben nur 2 Variablen wirklich Einfluss auf die AV, und zwar hemoglobin und dental_caries. Es wurde aber als Warnung ausgegeben, dass es eine mögliche Multikollinearität zwischen relaxation und sysolic, HDL und Cholosterol, HDL und triglyceride und waistund weightgibt. Dadurch könnten die Ergebnisse verfälscht werden und der Anteil, der sich im rope befindet, verschieben. Deshalb ist es schwierig zu sagen, ob noch andere Variablen einen identifizierten Effekt auf die AV haben.\nDer Varianzinflationsfaktor (VIF) wird verwendet, um Multikollinearität zwischen den Prädiktoren in einem Regressionsmodell zu quantifizieren. Die betroffenen Variablen scheinen alle ein höheren Faktor zu haben als die anderen.\nEs macht aber Sinn, dass die Variablen-Pärchen eine Korrelation aufweisen, denn zum Beispiel stehen die Variablen relaxation und sysolic beide im Zusammenhang mit dem Blutdruck, genauso wie es bei dem Taillenumfang (waist) und Gewicht auch Sinn macht, dass sie miteinander korrelieren.\n\n\n\n\n\nVerschiedene Rezepte mit unterschiedlicher Vorverarbeitung, um am Ende das beste zu finden.\nAufgrund von hohen Rechenzeiten habe ich mich dafür entschieden, mein test-sample aus dem Split-Objekt zu verwenden.\n\n# Rezept basic\nrec1 &lt;-\n  recipe(smokingf ~ ., data = test) %&gt;% \n  update_role(id, new_role = \"id variable\" )\n\n\ntidy(rec1)\n\n\n\n  \n\n\nd_baked1 &lt;- prep(rec1) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked1))\n\n[1] 0\n\n# Basic Rezept mit Yeo Johnson & step normalize\nrec2 &lt;-\n  recipe(smokingf ~ ., data = test) %&gt;% \n  update_role(id, new_role = \"id variable\") |&gt; \n  step_normalize(all_numeric_predictors()) |&gt; \n  step_YeoJohnson(all_double_predictors())\n\ntidy(rec2)\n\n\n\n  \n\n\nd_baked2 &lt;- prep(rec2) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked2))\n\n[1] 0\n\n# Rezept 3\nrec3 &lt;-\n  recipe(smokingf ~ height + weight + hemoglobin + triglyceride + Gtp + serum_creatinine + HDL + waist + age, data = test) %&gt;%\n  step_normalize(all_numeric_predictors())\n\ntidy(rec3)\n\n\n\n  \n\n\nd_baked3 &lt;- prep(rec3) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked3))\n\n[1] 0\n\n# Rezept 4\nrec4 &lt;-\n  recipe(smokingf ~ height + weight + hemoglobin + triglyceride + Gtp + serum_creatinine + HDL + waist + age, data = test) %&gt;%\n  step_normalize(all_numeric_predictors()) |&gt; \n  step_pca(all_numeric_predictors(), num_comp = 3) \n\ntidy(rec4)\n\n\n\n  \n\n\nd_baked4 &lt;- prep(rec4) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked4))\n\n[1] 0\n\n# Rezept 5 auf Basis des stan_glm\nrec5 &lt;-\n  recipe(smokingf ~ dental_caries + hemoglobin, data = test) %&gt;%\n  step_scale(all_numeric_predictors()) |&gt; \n  step_pca(all_numeric_predictors(), num_comp = 3) \n\ntidy(rec5)\n\n\n\n  \n\n\nd_baked5 &lt;- prep(rec5) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked5))\n\n[1] 0\n\n#Rezept 6 mit yeo Johnson und z-skalieren\nrec6 &lt;-\n  recipe(smokingf ~ ., data = test) %&gt;% \n  update_role(id, new_role = \"id variable\") |&gt; \n  step_normalize(all_numeric_predictors()) |&gt; \n  step_scale(all_numeric_predictors()) |&gt; \n  step_YeoJohnson(all_double_predictors())\n\ntidy(rec6)\n\n\n\n  \n\n\nd_baked6 &lt;- prep(rec6) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked6))\n\n[1] 0\n\n\n\n\n\n\nset.seed(42)\ncv_scheme &lt;- vfold_cv(test,\n  v = 5, \n  repeats = 2,\n  strata = smokingf)\n\n\n\n\n\n# Baum\nmod_tree &lt;-\n  decision_tree(cost_complexity = tune(),\n  tree_depth = tune(),\n  mode = \"classification\")\n\n# Random Forest\nmod_rf &lt;-\n  rand_forest(mtry = tune(),\n  min_n = tune(),\n  trees = 1000,\n  mode = \"classification\") %&gt;% \n  set_engine(\"ranger\", num.threads = 4)\n\n# XGBoost\n\nmod_boost &lt;- boost_tree(\n  mode = \"classification\",\n  engine = \"xgboost\",\n  mtry = tune(),\n  trees = 100,\n  min_n = 10\n)\n\n\n# logistische Regression\nmod_logreg &lt;- logistic_reg(\n              mode = \"classification\",\n              engine = \"glm\",\n              penalty = 1)\n\n\n# knn\nmod_knn &lt;-\n  nearest_neighbor(\n    mode = \"classification\",\n    engine = \"kknn\",\n    neighbors = tune()\n  ) \n\n\n\n\n\n\nShow the code\npreproc1 &lt;- list(rec1 = rec1)\n\nmodels1 &lt;- list(tree1 = mod_tree, rf1 = mod_rf, boost1 = mod_boost, lg1 = mod_logreg, knn1 = mod_knn)\n\nmodels2 &lt;- list(tree1 = mod_tree, boost1 = mod_boost, lg1 = mod_logreg, knn1 = mod_knn)\n\n# mit Rezept 1\nall_workflows1 &lt;- workflow_set(preproc1, models2)\n\n# mit Rezept 2\npreproc2 &lt;- list(rec2 = rec2)\nall_workflows2 &lt;- workflow_set(preproc2, models2)\n\n# mit Rezept 3\npreproc3 &lt;- list(rec3 = rec3)\nall_workflows3 &lt;- workflow_set(preproc3, models2)\n\n# mit Rezept 4\npreproc4 &lt;- list(rec4 = rec4)\nall_workflows4 &lt;- workflow_set(preproc4, models2)\n\n# mit Rezept 5\npreproc5 &lt;- list(rec5 = rec5)\nall_workflows5 &lt;- workflow_set(preproc5, models2)\n\n# mit Rezept 6\npreproc6 &lt;- list(rec6 = rec6)\nall_workflows6 &lt;- workflow_set(preproc6, models2)\n\n\n\nworkflow6 &lt;-\n  workflow() |&gt; \n  add_model(mod_boost) |&gt; \n  add_recipe(rec6)\n\n\n\n\n\n\nShow the code\n# mit Rezept 2\nset.seed(42)\ntic()\nsmokingset2 &lt;-\n  all_workflows2 %&gt;% \n  workflow_map(\n  resamples = cv_scheme,\n  grid = 10,\n  verbose = TRUE)\ntoc()\n\n# mit Rezept 3\nset.seed(42)\ntic()\nsmokingset3 &lt;-\n  all_workflows3 %&gt;% \n  workflow_map(\n  resamples = cv_scheme,\n  grid = 10,\n  verbose = TRUE)\ntoc()\n\n# mit Rezept 4\nset.seed(42)\ntic()\nsmokingset4 &lt;-\n  all_workflows4 %&gt;% \n  workflow_map(\n  resamples = cv_scheme,\n  grid = 10,\n  verbose = TRUE)\ntoc()\n\n# mit Rezept 5\nset.seed(42)\ntic()\nsmokingset5 &lt;-\n  all_workflows5 %&gt;% \n  workflow_map(\n  resamples = cv_scheme,\n  grid = 10,\n  verbose = TRUE)\ntoc()\n\n# mit Rezept 6\nset.seed(42)\ntic()\nsmokingset6 &lt;-\n  all_workflows6 %&gt;% \n  workflow_map(\n  resamples = cv_scheme,\n  grid = 10,\n  verbose = TRUE)\ntoc()\n\n\nBester Workflow, dieser hat sich durch ausprobieren der Workflowsets ergeben. Aufgrund von Rechenzeitersparnis wird hier nur noch mit dem besten Workflow weitergearbeitet.\n\n# mit Rezept 6\nset.seed(42)\ntic()\ntune6 &lt;-\n  tune_grid(object = workflow6,\n            resamples = cv_scheme,\n            grid = 10,\n            control = control_grid(save_workflow = TRUE))\n\ni Creating pre-processing data to finalize unknown parameter: mtry\n\n\ni The workflow being saved contains a recipe, which is 5.74 Mb in i memory. If\nthis was not intentional, please set the control setting i `save_workflow =\nFALSE`.\n\ntoc()\n\n348.19 sec elapsed\n\n\n\n\n\n\n\nShow the code\n# mit Rezept 2\ntune::autoplot(smokingset2) +\n  theme(legend.position = \"bottom\")\n\nsmokingset2 %&gt;% \n  collect_metrics(.metric = \"roc_auc\") %&gt;% \n  arrange(mean) \n\n# mit Rezept 3\ntune::autoplot(smokingset3) +\n  theme(legend.position = \"bottom\")\n\nsmokingset3 %&gt;% \n  collect_metrics(.metric = \"roc_auc\") %&gt;% \n  arrange(mean) \n\n# mit Rezept 4\ntune::autoplot(smokingset4) +\n  theme(legend.position = \"bottom\")\n\nsmokingset4 %&gt;% \n  collect_metrics(.metric = \"roc_auc\") %&gt;% \n  arrange(mean) \n\n# mit Rezept 5\ntune::autoplot(smokingset5) +\n  theme(legend.position = \"bottom\")\n\nsmokingset5 %&gt;% \n  collect_metrics(.metric = \"roc_auc\") %&gt;% \n  arrange(mean) \n\n# mit Rezept 6\ntune::autoplot(smokingset6) +\n  theme(legend.position = \"bottom\")\n\nsmokingset6 %&gt;% \n  collect_metrics() %&gt;% \n  arrange(mean) \n\n\nBestes Workflowset:\n\n# mit Rezept 6\ntune6 |&gt; collect_metrics()\n\n\n\n  \n\n\nautoplot(tune6)\n\n\n\n\n\n\n\nDer beste workflow scheint eine Kombination aus einem xgBoost-Modell und dem 6. Rezept zu sein. Die accuracy liegt bei ca. 0.771 und der roc_auc wert bei 0.856.\n\nbest_model6 &lt;-\n  fit_best(tune6)\n\n\n\n\n\n\nfinal_preds6 &lt;- \n  best_model6 %&gt;% \n  predict(new_data = d_test, type = \"prob\") %&gt;% \n  bind_cols(d_test)\n\nsubmission &lt;-\n  final_preds6 |&gt; \n  mutate(pred_prob = .pred_1,\n         pred_class = round(.pred_1, 0)) |&gt; \n  dplyr::select(id, pred_class, pred_prob)\n\n\n\nAnhand dem eigenen train-sample wird die roc-auc Kurve dargestellt.\n\nprobe &lt;- \n  best_model6 %&gt;% \n  predict(new_data = train, type = \"prob\")\n\n\ntrain2 &lt;- train |&gt; \n  mutate(smoking = as.numeric(smokingf))\nrocobj &lt;- roc(train2$smoking, probe$.pred_1)\n\nSetting levels: control = 1, case = 2\n\n\nSetting direction: controls &lt; cases\n\n#define object to plot and calculate AUC\nrocobj &lt;- roc(train2$smoking, probe$.pred_1)\n\nSetting levels: control = 1, case = 2\nSetting direction: controls &lt; cases\n\nauc &lt;- round(auc(train2$smoking, probe$.pred_1),4)\n\nSetting levels: control = 1, case = 2\nSetting direction: controls &lt; cases\n\n#create ROC plot\nggroc(rocobj, colour = 'cyan', size = 1) +\n  ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')')) +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\nDas Modell ist in der Lage, die positiven Fälle von den negativen Fällen mit einer Wahrscheinlichkeit von ca. 86 % zu unterscheiden.\nEs ist wichtig zu beachten, dass der ROC AUC-Wert nur ein Maß für die Fähigkeit eines Modells ist, die positiven Fälle von den negativen Fällen zu unterscheiden. Er sagt nichts darüber aus, wie gut das Modell die tatsächlichen Werte der positiven Fälle vorhersagt.\n\n\n\n\nprobe2 &lt;-\n  probe |&gt; \n  bind_cols(train2)\n\nprobe2 &lt;-\n  probe2 |&gt; \n  mutate(pred1 = round(.pred_1)) |&gt; \n  mutate(predf = factor(pred1))\n\nconfusion_matrix &lt;- confusionMatrix(probe2$smokingf, probe2$predf)\nprint(confusion_matrix)\n\nConfusion Matrix and Statistics\n\n          Reference\nPrediction     0     1\n         0 54390 17292\n         1 11529 44193\n                                          \n               Accuracy : 0.7738          \n                 95% CI : (0.7715, 0.7761)\n    No Information Rate : 0.5174          \n    P-Value [Acc &gt; NIR] : &lt; 2.2e-16       \n                                          \n                  Kappa : 0.5456          \n                                          \n Mcnemar's Test P-Value : &lt; 2.2e-16       \n                                          \n            Sensitivity : 0.8251          \n            Specificity : 0.7188          \n         Pos Pred Value : 0.7588          \n         Neg Pred Value : 0.7931          \n             Prevalence : 0.5174          \n         Detection Rate : 0.4269          \n   Detection Prevalence : 0.5626          \n      Balanced Accuracy : 0.7719          \n                                          \n       'Positive' Class : 0               \n                                          \n\n\nDie Sensitivität ist ein Maß dafür, wie gut das Modell positive Fälle (Nicht-Raucher) erkennt. In diesem Fall ist die Sensitivität von 0,8271 gut. Das Modell erkennt 82,71 % der positiven Fälle korrekt.\nDie Spezifität ist ein Maß dafür, wie gut das Modell negative Fälle (Raucher) erkennt. In diesem Fall ist die Spezifität von 0,7194 auch gut. Das Modell erkennt 71,94 % der negativen Fälle korrekt.\n\n\n\n\nEs sollten innerhalb dieser Analyse zwei Fragen bzw. Aufgaben bewältigit werden. Zum einem sollten die mögliche Effekte auf den Raucherstatus identifiziert werden, zum anderen sollten Beobachtungsfälle aufgrund ihrer biologischen Daten nach ihrem Raucherstatus klassifiziert werden bzw. es sollte die Wahrscheinlichkeit, ob jemand Raucher ist, angegeben werden.\nEs wurden zwei Effekte auf die AV smoking identifiziert, einmal hemoglobin und dental_caries. Es kann jedoch nicht mit Sicherheit gesagt werden, ob es nicht noch mehr geben könnte, denn im Modell befinden sich Hinweise auf eine mögliche Multikollinerität.\nDas Klassifikations-Modell ist in der Lage, die positiven Fälle von den negativen Fällen mit einer Wahrscheinlichkeit von ca. 86 % zu unterscheiden.\nIm Allgemeinen kann man sagen: Die Klassifikation des Raucherstatus auf der Grundlage biologischer Signale hat einige Vorteile gegenüber der Klassifikation auf der Grundlage von Selbstberichten. Selbstberichte sind anfällig für Verzerrungen, z. B. soziale Erwünschtheit oder Erinnerungsfehler. Biologische Signale hingegen sind objektive Messungen, die nicht von den subjektiven Wahrnehmungen der Person abhängen.\nEs gibt jedoch auch einige Herausforderungen bei der Klassifikation des Raucherstatus auf der Grundlage biologischer Signale. Zum einen sind die biologischen Signale von Rauchern und Nichtrauchern nicht immer eindeutig voneinander zu unterscheiden. Zum anderen können die biologischen Signale durch andere Faktoren beeinflusst werden, z. B. durch die Ernährung oder die Einnahme von Medikamenten.\n\n\n\nRaucheranteil Deutschland: WHO. (31. August, 2015). Anteil der Raucher in Deutschland nach Geschlecht in den Jahren 2000 bis 2025 [Graph]. In Statista. Zugriff am 12. Januar 2024, von https://de.statista.com/statistik/daten/studie/596512/umfrage/verbreitung-des-rauchens-in-deutschland-nach-geschlecht/\nTriglyceride-Werte: Rassow, J., & Netzker, D. (2016). Duale Reihe Biochemie, Thieme. Edited by J. Rassow et al. Stuttgart: Georg Thieme Verlag.\nHämoglobin-Werte: https://www.blutspende.de/magazin/von-a-bis-0/was-ist-haemoglobin-und-warum-ist-es-wichtig"
  },
  {
    "objectID": "posts/Angewandtes Projekt/Projekt.html#forschungsfrage",
    "href": "posts/Angewandtes Projekt/Projekt.html#forschungsfrage",
    "title": "Raucherstatus Klassifikation",
    "section": "",
    "text": "Im Folgenden sollen sowohl neue Beobachtungsfälle auf ihre Wahrscheinlichkeit hin, Raucher zu sein, klassifiziert werden, als auch mögliche Effekte von biologischen Signalen auf den Raucherstatus identifiziert werden.\nWarum könnte eine Klassifikation des Raucherstatus interessieren?\n\n\nGesundheitswesen: Eine Klassifikation des Raucherstatus auf Basis von biologischen Signalen kann verwendet werden, um Menschen mit einem erhöhten Risiko für Raucherkrankheiten zu identifizieren. Dies kann dazu beitragen, diese Krankheiten zu verhindern oder zu behandeln.\nRaucherentwöhnung: Eine Klassifikation des Raucherstatus auf Basis von biologischen Signalen kann verwendet werden, um die Wirksamkeit von Raucherentwöhnungsmaßnahmen zu bewerten. Dies kann dazu beitragen, die Entwicklung neuer und effektiverer Raucherentwöhnungsmaßnahmen zu unterstützen.\nMarktforschung: Eine Klassifikation des Raucherstatus auf Basis von biologischen Signalen kann verwendet werden, um neue Produkte und Dienstleistungen für Raucher zu entwickeln. Dies kann dazu beitragen, die Raucherprävention und -entwöhnung zu unterstützen."
  },
  {
    "objectID": "posts/Angewandtes Projekt/Projekt.html#vorbereitung",
    "href": "posts/Angewandtes Projekt/Projekt.html#vorbereitung",
    "title": "Raucherstatus Klassifikation",
    "section": "",
    "text": "library(tidyverse)\nlibrary(tidymodels)\nlibrary(easystats)\nlibrary(glmnet)\nlibrary(corrr)\nlibrary(fastDummies)\nlibrary(reshape2)\nlibrary(lubridate)\nlibrary(tictoc)\nlibrary(xgboost)\nlibrary(doParallel)\nlibrary(cowplot)\nlibrary(rlang)\nlibrary(purrr)\nlibrary(timetk)\nlibrary(discrim)\nlibrary(ggthemes)\nlibrary(klaR)\nlibrary(rstanarm)\nlibrary(car)\nlibrary(caret)\nlibrary(pROC)\n\n\n\n\nDie Daten stammen von einer kaggle Competition. Es gibt einen train und einen test Datensatz.\nEs geht darum, Menschen als Raucher oder Nicht-Raucher anhand von verschiedenen biologischen Signalen und Eigenschaften zu klassifizieren. Dabei soll die Klassifikation aber nicht hart sein, also nur aussagen ob man Raucher ist oder nicht, sondern es soll eine weiche Klassifikation sein, die angibt, mit welcher Wahrscheinlichkeit jemand aufgrund der vorliegenden Daten Raucher ist.\n\nd_train &lt;- read_csv(path_train)\nd_test &lt;- read_csv(path_test)\n\nSchauen wir uns die Daten einmal an. Der Datensatz besteht aus 24 Variablen, wovon eine die ID-Spalte ist und eine die vorzusagende Variable smoking.\n\nd_train\n\n\n\n  \n\n\n\nDer Train Datensatz wird nochmal in train und test Daten gesplittet. Davor werden einige Variablen für einfacheres Handling noch umbenannt und die AV wird als Faktorvariable angelegt.\n\nd_train &lt;-\n  d_train |&gt; \n  mutate(weight = `weight(kg)`,\n         waist = `waist(cm)`,\n         height = `height(cm)`,\n         eyesight_left = `eyesight(left)`,\n         eyesight_right = `eyesight(right)`,\n         hearing_left = `hearing(left)`,\n         hearing_right = `hearing(right)`,\n         dental_caries = `dental caries`) |&gt; \n  dplyr::select(-`weight(kg)`, -`height(cm)`, -`eyesight(left)`, -`eyesight(right)`, -`hearing(left)`, -`hearing(right)`, - `dental caries`, -`waist(cm)`)\n\nd_test &lt;-\n  d_test |&gt; \n  mutate(weight = `weight(kg)`,\n         waist = `waist(cm)`,\n         height = `height(cm)`,\n         eyesight_left = `eyesight(left)`,\n         eyesight_right = `eyesight(right)`,\n         hearing_left = `hearing(left)`,\n         hearing_right = `hearing(right)`,\n         dental_caries = `dental caries`) |&gt; \n  dplyr::select(-`weight(kg)`, - `height(cm)`, -`eyesight(left)`, -`eyesight(right)`, -`hearing(left)`, -`hearing(right)`, - `dental caries`, -`waist(cm)`)\n\ncolnames(d_test) &lt;- gsub(\" \", \"_\", colnames(d_test))\n\nd_trainf &lt;-\n  d_train |&gt; \n  mutate(smokingf = factor(smoking)) |&gt; \n  dplyr::select(-smoking)\n\ncolnames(d_trainf) &lt;- gsub(\" \", \"_\", colnames(d_trainf))\n\nd_split &lt;- initial_split(d_trainf, prop = .8, strata = smokingf)\ntrain &lt;- training(d_split)\ntest &lt;- testing(d_split)"
  },
  {
    "objectID": "posts/Angewandtes Projekt/Projekt.html#überblick-über-die-daten-verschaffen",
    "href": "posts/Angewandtes Projekt/Projekt.html#überblick-über-die-daten-verschaffen",
    "title": "Raucherstatus Klassifikation",
    "section": "",
    "text": "sum(is.na(d_trainf))\n\n[1] 0\n\nvisdat::vis_dat(d_trainf, warn_large_data = FALSE)\n\n\n\n\nIm Datensatz gibt es keine fehlenden Werte. Bis auf die AV liegen nur nummerische Variablen vor.\n\n\n\n\n\nShow the code\ns_cor &lt;-\n  d_train |&gt;\n  dplyr::select(-id) |&gt; \n  correlate() |&gt; \n  shave()\n\ns_cor\n\n\n\n\n  \n\n\n\nShow the code\ns_cor2 &lt;-\n  d_train |&gt; \n  dplyr::select(-id)\n\ncorr_matrix &lt;- cor(s_cor2)\ncorr_melted &lt;- melt(corr_matrix)\n\nggplot(corr_melted, aes(x=Var1, y=Var2, fill=value)) + \n  geom_tile() +\n  scale_fill_gradient2(low=\"blue\", mid=\"white\", high=\"red\", midpoint=0) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +\n  labs(title=\"Korrelations-Heatmap für accidents\")\n\n\n\n\n\n\n\n\n\nd_train |&gt; \n  count(smoking == 1) |&gt; \n  mutate(Anteil = n/sum(n))\n\n\n\n  \n\n\n\n–&gt; Die AV scheint einigermaßen gleichverteilt zu sein.\n\n\n\n\n\nShow the code\n# Funktion zur Erstellung eines Histogramms mit Facettierung\ncreate_histogram_plot &lt;- function(data, variable) {\n  ggplot(data, aes(x = !!sym(variable))) +\n    geom_histogram() +\n    labs(x = variable, y = \"Häufigkeit\") +\n    theme(\n    text = element_text(color = \"darkblue\"),  # Ändere die Farbe des Texts\n    panel.background = element_rect(fill = \"lightgray\"),  # Hintergrundfarbe des Plots\n    panel.grid.major = element_line(color = \"white\"),  # Farbe der Hauptgitterlinien\n    panel.grid.minor = element_line(color = \"lightblue\"),  # Farbe der Nebengitterlinien\n    strip.background = element_rect(fill = \"cyan\"),  # Hintergrundfarbe der Facettenüberschriften\n    strip.text = element_text(color = \"black\"),  # Farbe des Texts in den Facettenüberschriften\n    axis.title = element_text(color = \"purple\"),  # Farbe der Achsentitel\n    axis.text = element_text(color = \"black\"),  # Farbe des Achsentexts\n    axis.line = element_line(color = \"blue\"),  # Farbe der Achsenlinien\n    panel.border = element_rect(color = \"darkgray\", fill = NA),  # Farbe der Panelgrenzen\n    plot.background = element_rect(fill = \"lightyellow\")  # Hintergrundfarbe des gesamten Plots\n  ) +\n    facet_wrap(~ ., scales = \"free\")\n}\n\n# Liste der Variablen, für die Plots erstellt werden sollen\nvariables_to_plot &lt;- c(\"smoking\", \"age\", \"height\", \"weight\", \"triglyceride\", \"hemoglobin\")\n\n# Erstelle die Plots für jede Variable\nplots_list &lt;- map(variables_to_plot, ~ create_histogram_plot(data = d_train, variable = .x))\n\n# Kombiniere die Plots in einem Raster\nplot_grid(plotlist = plots_list, ncol = 3)\n\n\n\n\n\nDie Variable smoking ist einigermaßen gleichverteilt, was für die Klassifikation natürlich sinnvoll ist, jedoch vielleicht kein gutes Bild der gesamten Population. In Deutschland liegt der Anteil an regelmäßig Rauchenden bei ca. 25 % (WHO, 2025).\nDie Variable age ist einigermaßen erwartungsmäßig verteilt, wobei es einen erstaunlich hohen Anteil an 40 Jährigen gibt.\nDie Variablen heigth und weight sind beide wie zu erwarten normalverteilt.\ntriglyceride, welche im medizinischen Bereich auch im Rahmen der Blutanalyse gemessen werden und zusammen mit Cholosterol zur Bestimmung von Fettwechselstörung notwendig sind, liegen bei einem Erwachsenen zwischen 40 - 240 mg/dl (natürlich auch abhängig von Alter und Geschlecht) (Rassow & Netzker, 2016). Deshalb macht die Verteilung der Werte auch Sinn so wie dargestellt.\nhemoglobin ist Teil der roten Blutkörperchen und ein Protein, in dessen Mitte ein Eisenatom liegt, welches Sauerstoff anlagern kann. Typische Werte liegen zwischen 12 und 19 g/dl (natürlich auch wieder abhängig von Alter und Geschlecht) (DRK, 2021), weshalb auch hier die Verteilung wieder sinnvoll erscheint.\n\n\n\n\n\nShow the code\n# Plot für Alter erstellen\n\nggplot(d_trainf, aes(x = age, fill = smokingf)) +\n  geom_bar(position = \"dodge\", width = 4)  +\n  labs(title = \"Häufigkeit von Alter nach Raucherstatus\",\n       x = \"Alter\",\n       y = \"Häufigkeit\",\n       fill = \"Raucher\")  +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\nWarning: `position_dodge()` requires non-overlapping x intervals\n\n\n\n\n\nDer größte Anteil in beiden Gruppen scheint bei 40 Jahren zu sein. Bei den Rauchern scheint es aber nochmal einen beachtlichen Anteil an 60 Jährigen zu geben im Vergleich zu den Nicht-Rauchern.\n\n\nShow the code\n# Plot für Gewicht erstellen\n\nggplot(d_trainf, aes(x = weight, fill = smokingf)) +\n  geom_bar(position = \"dodge\", width = 4)  +\n  labs(title = \"Häufigkeit von Gewicht nach Raucherstatus\",\n       x = \"Gewicht\",\n       y = \"Häufigkeit\",\n       fill = \"Raucher\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\nWarning: `position_dodge()` requires non-overlapping x intervals\n\n\n\n\n\nDie Nicht-Raucher haben bis 65 kg den höheren Anteil an der Verteilung, darüber gibt es mehr Raucher als Nicht-Raucher.\n\n\nShow the code\n# Plot für Größe erstellen\n\nggplot(d_trainf, aes(x = height, fill = smokingf)) +\n  geom_bar(position = \"dodge\", width = 4)  +\n  labs(title = \"Häufigkeit von Größe nach Raucherstatus\",\n       x = \"Größe\",\n       y = \"Häufigkeit\",\n       fill = \"Raucher\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\nWarning: `position_dodge()` requires non-overlapping x intervals\n\n\n\n\n\nEs gibt sehr viel mehr kleinere Nicht-Raucher als kleine Raucher (klein: &lt; 160 cm). Andersherum gibt es viel mehr große Raucher (groß: &gt; 170 cm) als große Nicht-Raucher. Interessant wäre hierbei noch zu wissen, wie die Geschlechterverteilung aussieht, denn falls es mehr männliche als weibliche Raucher geben würde, dann macht es auch Sinn, dass es mehr große Raucher gibt. Leider gibt es dazu keine Daten in dem Datensatz.\n\n\nShow the code\n# Plot für Karies erstellen\n\nggplot(d_trainf, aes(x = dental_caries, fill = smokingf)) +\n  geom_bar(position = \"dodge\") +\n  labs(title = \"Häufigkeit von Karies nach Raucherstatus\",\n       x = \"Karies\",\n       y = \"Häufigkeit\",\n       fill = \"Raucher\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nInsgesamt gibt es viel weniger Menschen mit Karies, wobei es etwas mehr Raucher als Nicht-Raucher sind.\n\n\n\nHier waren einmal typische Merkmalen der Beobachtungsfälle interessant als auch vereinzelte Daten zu biochemischen Signalen.\n\n\nShow the code\nggplot(d_trainf, aes(x = smokingf, y = height, fill = smokingf)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot der Größe nach Raucherstatus\", x = \"Raucherstatus\", y = \"Größe\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  summarise(mean(height))\n\n\n\n\n  \n\n\n\nAnscheinend sind Raucher (mean = 169.74 cm) im Durchschnitt etwas größer als Nicht-Raucher (mean = 161.79 cm). Zudem scheinen Nicht-Raucher breiter gestreut zu sein als Raucher. Die Verteilung zur Größer der Nicht-Raucher könnte möglicherweise auch nicht ganz normalverteilt sein. Die\n\n\nShow the code\nggplot(d_trainf, aes(x = smokingf, y = weight, fill = smokingf)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot des Gewichts nach Raucherstatus\", x = \"Raucherstatus\", y = \"Gewicht\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  summarise(mean(weight))\n\n\n\n\n  \n\n\n\nNicht-Raucher scheinen im Durchschnitt mit 63.24 kg etwas leichter zu sein als die Raucher mit 72.16 kg. Die Nicht-Raucher haben mehr Ausreißer nach oben hin, während es bei den Rauchern sowohl Ausreißer nach unten als nach oben gibt. Beide Gruppen scheinen nicht ganz normalverteilt zu sein.\n\n\nShow the code\nggplot(d_trainf, aes(x = smokingf, y = age, fill = smokingf)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot des Alters nach Raucherstatus\", x = \"Raucherstatus\", y = \"Alter\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  summarise(mean(age))\n\n\n\n\n  \n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  count(age &lt; 20)\n\n\n\n\n  \n\n\n\nRaucher liegen mit 41.5 Jahren durschnittlich unter den Nicht-Rauchern mit 46.5 Jahren. Es gibt in beiden Gruppen keine Personen, die unter 20 Jahren sind, also wurden wohl nur Daten zu Personen &gt;= 20 gesammelt. Beide Gruppen scheinen nicht ganz normalverteilt zu sein.\n\n\nShow the code\nggplot(d_trainf, aes(x = smokingf, y = Cholesterol, fill = smokingf)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot Cholersterol nach Raucherstatus\", x = \"Raucherstatus\", y = \"Cholesterol\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  summarise(mean(Cholesterol))\n\n\n\n\n  \n\n\n\nDie Cholosterol-Spiegel sind für beide Gruppen ähnlich. Auch sonst gibt es wenig Auffäligkeiten.\n\n\nShow the code\nggplot(d_trainf, aes(x = smokingf, y = hemoglobin, fill = smokingf)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot des Hemoglobins nach Raucherstatus\", x = \"Raucherstatus\", y = \"Hemoglobin\") +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\n\nShow the code\nd_trainf |&gt; \n  group_by(smokingf) |&gt; \n  summarise(mean(hemoglobin))\n\n\n\n\n  \n\n\n\nDer Hämoglobin Wert für die Raucher liegt knapp über 15, während er bei den Nicht-Rauchern knapp unter 15 liegt. Bei den Nicht-Raucher gehen die Ausreißer jedoch auch unter den Wert 7.5, während es bei den Rauchern etwas mehr Ausreißer nach oben hin gibt bzw diese haben höhere Werte als die Ausreißer der Nicht-Raucher."
  },
  {
    "objectID": "posts/Angewandtes Projekt/Projekt.html#effekte-identifizieren",
    "href": "posts/Angewandtes Projekt/Projekt.html#effekte-identifizieren",
    "title": "Raucherstatus Klassifikation",
    "section": "",
    "text": "Um zu überprüfen, welche Variablen einen Einfluss auf die AV haben, wurde im Folgenden ein stan_glm aufgestellt und anschließend das rope berechnet.\n\nm1 &lt;- stan_glm(smoking ~ ., data = d_train, seed = 42, refresh = 0)\n\nparameters(m1)\n\n\n\n  \n\n\nrope(m1)\n\nPossible multicollinearity between relaxation and systolic (r = 0.72), HDL and Cholesterol (r = 0.72), HDL and triglyceride (r = 0.7), waist and weight (r = 0.79). This might lead to inappropriate results. See 'Details' in '?rope'.\n\n\n\n\n  \n\n\nplot(rope(m1))\n\nPossible multicollinearity between relaxation and systolic (r = 0.72), HDL and Cholesterol (r = 0.72), HDL and triglyceride (r = 0.7), waist and weight (r = 0.79). This might lead to inappropriate results. See 'Details' in '?rope'.\n\n\n\n\nvif(m1)\n\n                   id                   age              systolic \n             1.018681              1.887934              2.587834 \n           relaxation `fasting blood sugar`           Cholesterol \n             2.505630              1.142631              7.455405 \n         triglyceride                   HDL                   LDL \n             3.078763              3.389189              6.134903 \n           hemoglobin       `Urine protein`    `serum creatinine` \n             1.905295              1.017452              1.445274 \n                  AST                   ALT                   Gtp \n             1.741287              1.959108              1.339327 \n               weight                 waist                height \n             6.919126              4.749702              2.929081 \n        eyesight_left        eyesight_right          hearing_left \n             1.319455              1.342833              1.487325 \n        hearing_right         dental_caries \n             1.460736              1.026594 \n\n\nAnscheinend haben nur 2 Variablen wirklich Einfluss auf die AV, und zwar hemoglobin und dental_caries. Es wurde aber als Warnung ausgegeben, dass es eine mögliche Multikollinearität zwischen relaxation und sysolic, HDL und Cholosterol, HDL und triglyceride und waistund weightgibt. Dadurch könnten die Ergebnisse verfälscht werden und der Anteil, der sich im rope befindet, verschieben. Deshalb ist es schwierig zu sagen, ob noch andere Variablen einen identifizierten Effekt auf die AV haben.\nDer Varianzinflationsfaktor (VIF) wird verwendet, um Multikollinearität zwischen den Prädiktoren in einem Regressionsmodell zu quantifizieren. Die betroffenen Variablen scheinen alle ein höheren Faktor zu haben als die anderen.\nEs macht aber Sinn, dass die Variablen-Pärchen eine Korrelation aufweisen, denn zum Beispiel stehen die Variablen relaxation und sysolic beide im Zusammenhang mit dem Blutdruck, genauso wie es bei dem Taillenumfang (waist) und Gewicht auch Sinn macht, dass sie miteinander korrelieren."
  },
  {
    "objectID": "posts/Angewandtes Projekt/Projekt.html#workflows",
    "href": "posts/Angewandtes Projekt/Projekt.html#workflows",
    "title": "Raucherstatus Klassifikation",
    "section": "",
    "text": "Verschiedene Rezepte mit unterschiedlicher Vorverarbeitung, um am Ende das beste zu finden.\nAufgrund von hohen Rechenzeiten habe ich mich dafür entschieden, mein test-sample aus dem Split-Objekt zu verwenden.\n\n# Rezept basic\nrec1 &lt;-\n  recipe(smokingf ~ ., data = test) %&gt;% \n  update_role(id, new_role = \"id variable\" )\n\n\ntidy(rec1)\n\n\n\n  \n\n\nd_baked1 &lt;- prep(rec1) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked1))\n\n[1] 0\n\n# Basic Rezept mit Yeo Johnson & step normalize\nrec2 &lt;-\n  recipe(smokingf ~ ., data = test) %&gt;% \n  update_role(id, new_role = \"id variable\") |&gt; \n  step_normalize(all_numeric_predictors()) |&gt; \n  step_YeoJohnson(all_double_predictors())\n\ntidy(rec2)\n\n\n\n  \n\n\nd_baked2 &lt;- prep(rec2) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked2))\n\n[1] 0\n\n# Rezept 3\nrec3 &lt;-\n  recipe(smokingf ~ height + weight + hemoglobin + triglyceride + Gtp + serum_creatinine + HDL + waist + age, data = test) %&gt;%\n  step_normalize(all_numeric_predictors())\n\ntidy(rec3)\n\n\n\n  \n\n\nd_baked3 &lt;- prep(rec3) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked3))\n\n[1] 0\n\n# Rezept 4\nrec4 &lt;-\n  recipe(smokingf ~ height + weight + hemoglobin + triglyceride + Gtp + serum_creatinine + HDL + waist + age, data = test) %&gt;%\n  step_normalize(all_numeric_predictors()) |&gt; \n  step_pca(all_numeric_predictors(), num_comp = 3) \n\ntidy(rec4)\n\n\n\n  \n\n\nd_baked4 &lt;- prep(rec4) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked4))\n\n[1] 0\n\n# Rezept 5 auf Basis des stan_glm\nrec5 &lt;-\n  recipe(smokingf ~ dental_caries + hemoglobin, data = test) %&gt;%\n  step_scale(all_numeric_predictors()) |&gt; \n  step_pca(all_numeric_predictors(), num_comp = 3) \n\ntidy(rec5)\n\n\n\n  \n\n\nd_baked5 &lt;- prep(rec5) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked5))\n\n[1] 0\n\n#Rezept 6 mit yeo Johnson und z-skalieren\nrec6 &lt;-\n  recipe(smokingf ~ ., data = test) %&gt;% \n  update_role(id, new_role = \"id variable\") |&gt; \n  step_normalize(all_numeric_predictors()) |&gt; \n  step_scale(all_numeric_predictors()) |&gt; \n  step_YeoJohnson(all_double_predictors())\n\ntidy(rec6)\n\n\n\n  \n\n\nd_baked6 &lt;- prep(rec6) |&gt; bake(new_data = NULL)\nsum(is.na(d_baked6))\n\n[1] 0\n\n\n\n\n\n\nset.seed(42)\ncv_scheme &lt;- vfold_cv(test,\n  v = 5, \n  repeats = 2,\n  strata = smokingf)\n\n\n\n\n\n# Baum\nmod_tree &lt;-\n  decision_tree(cost_complexity = tune(),\n  tree_depth = tune(),\n  mode = \"classification\")\n\n# Random Forest\nmod_rf &lt;-\n  rand_forest(mtry = tune(),\n  min_n = tune(),\n  trees = 1000,\n  mode = \"classification\") %&gt;% \n  set_engine(\"ranger\", num.threads = 4)\n\n# XGBoost\n\nmod_boost &lt;- boost_tree(\n  mode = \"classification\",\n  engine = \"xgboost\",\n  mtry = tune(),\n  trees = 100,\n  min_n = 10\n)\n\n\n# logistische Regression\nmod_logreg &lt;- logistic_reg(\n              mode = \"classification\",\n              engine = \"glm\",\n              penalty = 1)\n\n\n# knn\nmod_knn &lt;-\n  nearest_neighbor(\n    mode = \"classification\",\n    engine = \"kknn\",\n    neighbors = tune()\n  ) \n\n\n\n\n\n\nShow the code\npreproc1 &lt;- list(rec1 = rec1)\n\nmodels1 &lt;- list(tree1 = mod_tree, rf1 = mod_rf, boost1 = mod_boost, lg1 = mod_logreg, knn1 = mod_knn)\n\nmodels2 &lt;- list(tree1 = mod_tree, boost1 = mod_boost, lg1 = mod_logreg, knn1 = mod_knn)\n\n# mit Rezept 1\nall_workflows1 &lt;- workflow_set(preproc1, models2)\n\n# mit Rezept 2\npreproc2 &lt;- list(rec2 = rec2)\nall_workflows2 &lt;- workflow_set(preproc2, models2)\n\n# mit Rezept 3\npreproc3 &lt;- list(rec3 = rec3)\nall_workflows3 &lt;- workflow_set(preproc3, models2)\n\n# mit Rezept 4\npreproc4 &lt;- list(rec4 = rec4)\nall_workflows4 &lt;- workflow_set(preproc4, models2)\n\n# mit Rezept 5\npreproc5 &lt;- list(rec5 = rec5)\nall_workflows5 &lt;- workflow_set(preproc5, models2)\n\n# mit Rezept 6\npreproc6 &lt;- list(rec6 = rec6)\nall_workflows6 &lt;- workflow_set(preproc6, models2)\n\n\n\nworkflow6 &lt;-\n  workflow() |&gt; \n  add_model(mod_boost) |&gt; \n  add_recipe(rec6)\n\n\n\n\n\n\nShow the code\n# mit Rezept 2\nset.seed(42)\ntic()\nsmokingset2 &lt;-\n  all_workflows2 %&gt;% \n  workflow_map(\n  resamples = cv_scheme,\n  grid = 10,\n  verbose = TRUE)\ntoc()\n\n# mit Rezept 3\nset.seed(42)\ntic()\nsmokingset3 &lt;-\n  all_workflows3 %&gt;% \n  workflow_map(\n  resamples = cv_scheme,\n  grid = 10,\n  verbose = TRUE)\ntoc()\n\n# mit Rezept 4\nset.seed(42)\ntic()\nsmokingset4 &lt;-\n  all_workflows4 %&gt;% \n  workflow_map(\n  resamples = cv_scheme,\n  grid = 10,\n  verbose = TRUE)\ntoc()\n\n# mit Rezept 5\nset.seed(42)\ntic()\nsmokingset5 &lt;-\n  all_workflows5 %&gt;% \n  workflow_map(\n  resamples = cv_scheme,\n  grid = 10,\n  verbose = TRUE)\ntoc()\n\n# mit Rezept 6\nset.seed(42)\ntic()\nsmokingset6 &lt;-\n  all_workflows6 %&gt;% \n  workflow_map(\n  resamples = cv_scheme,\n  grid = 10,\n  verbose = TRUE)\ntoc()\n\n\nBester Workflow, dieser hat sich durch ausprobieren der Workflowsets ergeben. Aufgrund von Rechenzeitersparnis wird hier nur noch mit dem besten Workflow weitergearbeitet.\n\n# mit Rezept 6\nset.seed(42)\ntic()\ntune6 &lt;-\n  tune_grid(object = workflow6,\n            resamples = cv_scheme,\n            grid = 10,\n            control = control_grid(save_workflow = TRUE))\n\ni Creating pre-processing data to finalize unknown parameter: mtry\n\n\ni The workflow being saved contains a recipe, which is 5.74 Mb in i memory. If\nthis was not intentional, please set the control setting i `save_workflow =\nFALSE`.\n\ntoc()\n\n348.19 sec elapsed\n\n\n\n\n\n\n\nShow the code\n# mit Rezept 2\ntune::autoplot(smokingset2) +\n  theme(legend.position = \"bottom\")\n\nsmokingset2 %&gt;% \n  collect_metrics(.metric = \"roc_auc\") %&gt;% \n  arrange(mean) \n\n# mit Rezept 3\ntune::autoplot(smokingset3) +\n  theme(legend.position = \"bottom\")\n\nsmokingset3 %&gt;% \n  collect_metrics(.metric = \"roc_auc\") %&gt;% \n  arrange(mean) \n\n# mit Rezept 4\ntune::autoplot(smokingset4) +\n  theme(legend.position = \"bottom\")\n\nsmokingset4 %&gt;% \n  collect_metrics(.metric = \"roc_auc\") %&gt;% \n  arrange(mean) \n\n# mit Rezept 5\ntune::autoplot(smokingset5) +\n  theme(legend.position = \"bottom\")\n\nsmokingset5 %&gt;% \n  collect_metrics(.metric = \"roc_auc\") %&gt;% \n  arrange(mean) \n\n# mit Rezept 6\ntune::autoplot(smokingset6) +\n  theme(legend.position = \"bottom\")\n\nsmokingset6 %&gt;% \n  collect_metrics() %&gt;% \n  arrange(mean) \n\n\nBestes Workflowset:\n\n# mit Rezept 6\ntune6 |&gt; collect_metrics()\n\n\n\n  \n\n\nautoplot(tune6)\n\n\n\n\n\n\n\nDer beste workflow scheint eine Kombination aus einem xgBoost-Modell und dem 6. Rezept zu sein. Die accuracy liegt bei ca. 0.771 und der roc_auc wert bei 0.856.\n\nbest_model6 &lt;-\n  fit_best(tune6)"
  },
  {
    "objectID": "posts/Angewandtes Projekt/Projekt.html#ergebnisse",
    "href": "posts/Angewandtes Projekt/Projekt.html#ergebnisse",
    "title": "Raucherstatus Klassifikation",
    "section": "",
    "text": "final_preds6 &lt;- \n  best_model6 %&gt;% \n  predict(new_data = d_test, type = \"prob\") %&gt;% \n  bind_cols(d_test)\n\nsubmission &lt;-\n  final_preds6 |&gt; \n  mutate(pred_prob = .pred_1,\n         pred_class = round(.pred_1, 0)) |&gt; \n  dplyr::select(id, pred_class, pred_prob)\n\n\n\nAnhand dem eigenen train-sample wird die roc-auc Kurve dargestellt.\n\nprobe &lt;- \n  best_model6 %&gt;% \n  predict(new_data = train, type = \"prob\")\n\n\ntrain2 &lt;- train |&gt; \n  mutate(smoking = as.numeric(smokingf))\nrocobj &lt;- roc(train2$smoking, probe$.pred_1)\n\nSetting levels: control = 1, case = 2\n\n\nSetting direction: controls &lt; cases\n\n#define object to plot and calculate AUC\nrocobj &lt;- roc(train2$smoking, probe$.pred_1)\n\nSetting levels: control = 1, case = 2\nSetting direction: controls &lt; cases\n\nauc &lt;- round(auc(train2$smoking, probe$.pred_1),4)\n\nSetting levels: control = 1, case = 2\nSetting direction: controls &lt; cases\n\n#create ROC plot\nggroc(rocobj, colour = 'cyan', size = 1) +\n  ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')')) +\n  scale_fill_tableau(\"Nuriel Stone\")\n\n\n\n\nDas Modell ist in der Lage, die positiven Fälle von den negativen Fällen mit einer Wahrscheinlichkeit von ca. 86 % zu unterscheiden.\nEs ist wichtig zu beachten, dass der ROC AUC-Wert nur ein Maß für die Fähigkeit eines Modells ist, die positiven Fälle von den negativen Fällen zu unterscheiden. Er sagt nichts darüber aus, wie gut das Modell die tatsächlichen Werte der positiven Fälle vorhersagt.\n\n\n\n\nprobe2 &lt;-\n  probe |&gt; \n  bind_cols(train2)\n\nprobe2 &lt;-\n  probe2 |&gt; \n  mutate(pred1 = round(.pred_1)) |&gt; \n  mutate(predf = factor(pred1))\n\nconfusion_matrix &lt;- confusionMatrix(probe2$smokingf, probe2$predf)\nprint(confusion_matrix)\n\nConfusion Matrix and Statistics\n\n          Reference\nPrediction     0     1\n         0 54390 17292\n         1 11529 44193\n                                          \n               Accuracy : 0.7738          \n                 95% CI : (0.7715, 0.7761)\n    No Information Rate : 0.5174          \n    P-Value [Acc &gt; NIR] : &lt; 2.2e-16       \n                                          \n                  Kappa : 0.5456          \n                                          \n Mcnemar's Test P-Value : &lt; 2.2e-16       \n                                          \n            Sensitivity : 0.8251          \n            Specificity : 0.7188          \n         Pos Pred Value : 0.7588          \n         Neg Pred Value : 0.7931          \n             Prevalence : 0.5174          \n         Detection Rate : 0.4269          \n   Detection Prevalence : 0.5626          \n      Balanced Accuracy : 0.7719          \n                                          \n       'Positive' Class : 0               \n                                          \n\n\nDie Sensitivität ist ein Maß dafür, wie gut das Modell positive Fälle (Nicht-Raucher) erkennt. In diesem Fall ist die Sensitivität von 0,8271 gut. Das Modell erkennt 82,71 % der positiven Fälle korrekt.\nDie Spezifität ist ein Maß dafür, wie gut das Modell negative Fälle (Raucher) erkennt. In diesem Fall ist die Spezifität von 0,7194 auch gut. Das Modell erkennt 71,94 % der negativen Fälle korrekt."
  },
  {
    "objectID": "posts/Angewandtes Projekt/Projekt.html#fazit",
    "href": "posts/Angewandtes Projekt/Projekt.html#fazit",
    "title": "Raucherstatus Klassifikation",
    "section": "",
    "text": "Es sollten innerhalb dieser Analyse zwei Fragen bzw. Aufgaben bewältigit werden. Zum einem sollten die mögliche Effekte auf den Raucherstatus identifiziert werden, zum anderen sollten Beobachtungsfälle aufgrund ihrer biologischen Daten nach ihrem Raucherstatus klassifiziert werden bzw. es sollte die Wahrscheinlichkeit, ob jemand Raucher ist, angegeben werden.\nEs wurden zwei Effekte auf die AV smoking identifiziert, einmal hemoglobin und dental_caries. Es kann jedoch nicht mit Sicherheit gesagt werden, ob es nicht noch mehr geben könnte, denn im Modell befinden sich Hinweise auf eine mögliche Multikollinerität.\nDas Klassifikations-Modell ist in der Lage, die positiven Fälle von den negativen Fällen mit einer Wahrscheinlichkeit von ca. 86 % zu unterscheiden.\nIm Allgemeinen kann man sagen: Die Klassifikation des Raucherstatus auf der Grundlage biologischer Signale hat einige Vorteile gegenüber der Klassifikation auf der Grundlage von Selbstberichten. Selbstberichte sind anfällig für Verzerrungen, z. B. soziale Erwünschtheit oder Erinnerungsfehler. Biologische Signale hingegen sind objektive Messungen, die nicht von den subjektiven Wahrnehmungen der Person abhängen.\nEs gibt jedoch auch einige Herausforderungen bei der Klassifikation des Raucherstatus auf der Grundlage biologischer Signale. Zum einen sind die biologischen Signale von Rauchern und Nichtrauchern nicht immer eindeutig voneinander zu unterscheiden. Zum anderen können die biologischen Signale durch andere Faktoren beeinflusst werden, z. B. durch die Ernährung oder die Einnahme von Medikamenten."
  },
  {
    "objectID": "posts/Angewandtes Projekt/Projekt.html#quellen",
    "href": "posts/Angewandtes Projekt/Projekt.html#quellen",
    "title": "Raucherstatus Klassifikation",
    "section": "",
    "text": "Raucheranteil Deutschland: WHO. (31. August, 2015). Anteil der Raucher in Deutschland nach Geschlecht in den Jahren 2000 bis 2025 [Graph]. In Statista. Zugriff am 12. Januar 2024, von https://de.statista.com/statistik/daten/studie/596512/umfrage/verbreitung-des-rauchens-in-deutschland-nach-geschlecht/\nTriglyceride-Werte: Rassow, J., & Netzker, D. (2016). Duale Reihe Biochemie, Thieme. Edited by J. Rassow et al. Stuttgart: Georg Thieme Verlag.\nHämoglobin-Werte: https://www.blutspende.de/magazin/von-a-bis-0/was-ist-haemoglobin-und-warum-ist-es-wichtig"
  },
  {
    "objectID": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html",
    "href": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html",
    "title": "Klassifikation von Hate Speech",
    "section": "",
    "text": "Textanalyse zur Klassifikation von Hatespeech\nlibrary(tidyverse)\nlibrary(easystats)\nlibrary(tidymodels)\nlibrary(tidytext)  \nlibrary(textrecipes)  \nlibrary(lsa)  \nlibrary(discrim)  \nlibrary(naivebayes)\nlibrary(tictoc)  \nlibrary(fastrtext)  \nlibrary(remoji)  \nlibrary(tokenizers)  \nlibrary(syuzhet)\nlibrary(pradadata)\nlibrary(beepr)\nlibrary(quanteda.textstats)\nlibrary(ggthemes)"
  },
  {
    "objectID": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#textlänge-in-abhängigkeit-von-c2-kategorie",
    "href": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#textlänge-in-abhängigkeit-von-c2-kategorie",
    "title": "Klassifikation von Hate Speech",
    "section": "Textlänge in Abhängigkeit von c2 Kategorie",
    "text": "Textlänge in Abhängigkeit von c2 Kategorie\n\n\nShow the code\ntrain1 &lt;-\n  germeval_train |&gt; \n  mutate(text_length = str_length(text))\n\nggplot(train1, aes(x = c1, y = text_length, color = c2)) +\n  geom_point() +\n  labs(title = \"Germeval 2018 Datensatz Visualisierung\",\n       x = \"c1\",\n       y = \"Textlänge\",\n       color = \"c2\") +\n  scale_color_tableau(\"Nuriel Stone\")"
  },
  {
    "objectID": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#histogramm-der-textlänge",
    "href": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#histogramm-der-textlänge",
    "title": "Klassifikation von Hate Speech",
    "section": "Histogramm der Textlänge",
    "text": "Histogramm der Textlänge\n\n\nShow the code\nggplot(train1, aes(x = text_length)) +\n  geom_histogram(binwidth = 5, fill = \"#94d0c0\", color = \"white\") +\n  labs(title = \"Histogramm der Textlängen\", x = \"Textlänge\", y = \"Häufigkeit\")"
  },
  {
    "objectID": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#boxplot-für-verschiedene-kateforien",
    "href": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#boxplot-für-verschiedene-kateforien",
    "title": "Klassifikation von Hate Speech",
    "section": "Boxplot für verschiedene Kateforien",
    "text": "Boxplot für verschiedene Kateforien\n\n\nShow the code\nggplot(train1, aes(x = c1, y = text_length, fill = c2)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot der Textlängen nach c1\", x = \"c1\", y = \"Textlänge\", fill = \"c2\")+\n  scale_fill_tableau(\"Nuriel Stone\")"
  },
  {
    "objectID": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#model-folds",
    "href": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#model-folds",
    "title": "Klassifikation von Hate Speech",
    "section": "Model & Folds",
    "text": "Model & Folds\n\n# model:\nmod1 &lt;-\n  rand_forest(mode = \"classification\")\n\n\n# cv:\nset.seed(42)\nrsmpl &lt;- vfold_cv(germeval_train, v = 5)"
  },
  {
    "objectID": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#recipe",
    "href": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#recipe",
    "title": "Klassifikation von Hate Speech",
    "section": "recipe:",
    "text": "recipe:\n\nrec 1\n\nd_train &lt;-\n  germeval_train |&gt; \n  select(id, c1, text)\n\n\nrec1 &lt;-\n  recipe(c1 ~ ., data = d_train) |&gt; \n  update_role(id, new_role = \"id\")  |&gt; \n  update_role(text, new_role = \"ignore\") |&gt; \n  step_mutate(n_schimpf = get_sentiment(text,  # aus `syuzhet`\n                                    method = \"custom\",\n                                    lexicon = schimpfwoerter)) |&gt; \n  step_mutate(n_emo = get_sentiment(text,  # aus `syuzhet`\n                                    method = \"custom\",\n                                    lexicon = sentiws))  |&gt;\n  step_tokenize(text) %&gt;%\n  step_stopwords(text, keep = FALSE) \n\nrec1_prepped &lt;- prep(rec1)\n\nd_rec1 &lt;- bake(rec1_prepped, new_data = NULL)\n\nhead(d_rec1)\n\n\n\n  \n\n\n\n\n\nrec2\n\nrec2 &lt;-\n  recipe(c1 ~ ., data = d_train) |&gt; \n  update_role(id, new_role = \"id\")  |&gt; \n  update_role(text, new_role = \"ignore\") |&gt; \n  step_mutate(n_schimpf = get_sentiment(text,  # aus `syuzhet`\n                                    method = \"custom\",\n                                    lexicon = schimpfwoerter)) |&gt; \n  step_mutate(n_emo = get_sentiment(text,  # aus `syuzhet`\n                                    method = \"custom\",\n                                    lexicon = sentiws))  |&gt; \n  step_tokenize(text) %&gt;%\n  step_stopwords(text, keep = FALSE) |&gt; \n  step_tokenfilter(text, max_tokens = 1e3) |&gt; \n  step_tfidf(text) \n\n\n\nrec2_prepped &lt;- prep(rec2)\n\nd_rec2 &lt;- bake(rec2_prepped, new_data = NULL)\n\nhead(d_rec2)"
  },
  {
    "objectID": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#workflow",
    "href": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#workflow",
    "title": "Klassifikation von Hate Speech",
    "section": "workflow:",
    "text": "workflow:\n\nwf1\n\nwf1 &lt;-\n  workflow() %&gt;% \n  add_model(mod1) %&gt;% \n  add_recipe(rec1)\n\n\n\nwf2\n\nwf2 &lt;-\n  workflow() %&gt;% \n  add_model(mod1) %&gt;% \n  add_recipe(rec2)"
  },
  {
    "objectID": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#fit1",
    "href": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#fit1",
    "title": "Klassifikation von Hate Speech",
    "section": "Fit1",
    "text": "Fit1\n\ntic()\nfit1 &lt;-\n  fit(wf1,\n      data = germeval_train)\ntoc()\n\n35.39 sec elapsed\n\nbeep(3)"
  },
  {
    "objectID": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#fit-2",
    "href": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#fit-2",
    "title": "Klassifikation von Hate Speech",
    "section": "Fit 2",
    "text": "Fit 2\n\ntic()\nfit2 &lt;-\n  fit(wf2,\n      data = germeval_train)\ntoc()\n\n111.2 sec elapsed\n\nbeep(3)"
  },
  {
    "objectID": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#pred1",
    "href": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#pred1",
    "title": "Klassifikation von Hate Speech",
    "section": "pred1",
    "text": "pred1\n\ntic()\npreds &lt;-\n  predict(fit1, new_data = germeval_test)\ntoc()\n\n22.39 sec elapsed"
  },
  {
    "objectID": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#pred2",
    "href": "posts/Miniprojekt/Miniprojekt_tidymodels_EmiliaBraun.html#pred2",
    "title": "Klassifikation von Hate Speech",
    "section": "pred2",
    "text": "pred2\n\ntic()\npreds2 &lt;-\n  predict(fit2, new_data = germeval_test)\ntoc()\n\n22.19 sec elapsed\n\n\n\nd_test &lt;-\n  germeval_test |&gt; \n  bind_cols(preds) |&gt; \n  mutate(c1 = as.factor(c1))\n\nd_test2 &lt;-\n  germeval_test |&gt; \n  bind_cols(preds2) |&gt; \n  mutate(c1 = as.factor(c1))\n\n\nmy_metrics &lt;- metric_set(accuracy, f_meas)\nmy_metrics(d_test,\n           truth = c1,\n           estimate = .pred_class)\n\n\n\n  \n\n\nmy_metrics &lt;- metric_set(accuracy, f_meas)\nmy_metrics(d_test2,\n           truth = c1,\n           estimate = .pred_class)"
  }
]